# Docker? ARM! 되고 말고!

[영상](https://www.youtube.com/watch?v=gQVES0NJ4Bg&list=PL42XJKPNDepZbqM9N11RxL5UY_5PbA_Wo&index=36&ab_channel=TOAST)

이 영상은 싱글 보드 컴퓨터(SBC)를 클러스터링해서 자체적으로 컨테이너 오케스트레이션을 구축한 것을 다룬다.

## 이게 왜 되지? 이게 왜 안되지?

발표자는 보드 컴퓨터를 여러개 묶어서 도커 인스턴스를 띄우는 것(docker run hello-world)까지 성공했다. 그래서 다른 애플리케이션도 실행해보고자 파이썬 애플리케이션을 구동해봤는데 실행이 불가능했다. 그래서 윈도와 맥의 도커와 비교를 해봤다.

1. 모두 hello-world는 동작한다.
2. 윈도와 맥에서 빌드한 이미지는 윈도와 맥에서 동작하지만, ARM에서는 동작하지 않는다.
3. 반대로 ARM에서 빌드한 이미지는 윈도와 맥에서 동작한다???

## 실행되지 않았던 이유

도커는 아래의 프로세스를 걸쳐 이미지를 빌드하고 실행한다.

1. 도커 파일을 생성하여 이미지로 빌드한다.
2. 이미지를 DockerHub와 같은 레지스트리에 push 하면 이미지가 업로드된다.
3. 이미지를 실행하기 위해, 머신에서 이미지를 pull 하면 이미지를 다운받는다.
4. docker run 으로 실행한다.

이때, 레지스트리는 타겟 OS와 아키텍처가 Linux와 AMD64이며, 이와 같아야 실행이 가능하다. 하지만 OS가 같아도 아키텍처가 다르면(명령어 체계가 다르기 때문에) pull 받을 수는 있지만 실행을 할 수 없다.

근데 hello-world는 어떻게 실행이 되었을까?

## 실행된 이유

docker run hello-world를 할 때, DockerHub에는 아키텍처별로 다른 이미지를 가지고있었기 때문이다.

docker pull IMAGE 를 실행하면, pull 한 환경에 대한 정보(OS, Arch)도 같이 실린다. 이 때 해당 정보를 읽어 레지스트리에서 적절한 이미지를 찾아 보내면 된다.

하지만 ARM의 경우에는 적절한 이미지가 없었기 때문에 default 이미지를 내려받은 것으로 추정된다.

## 반대로 ARM에서 빌드한 이미지가 윈도우, 맥에서 실행된 이유

PC의 환경에서 도커 데스크탑을 설치를 한다고 해보자. 도커는 리눅스 컨테이너 서비스이고, PC는 리눅스를 올리기 위해 HyperVisor를 먼저 올리고 리눅스를 올려 도커엔진 + `QEMU`를 실행한다. 

`QEMU`는 에뮬레이터로, **시스템 전체를 에뮬레이터 하거나 OS의 사용자 공간만 에뮬레이팅** 할 수 있다. 또한 리눅스 커널에는 `binary format misc` 라는 기능이 포함되어있다. 이는 리눅스에서 어떤 바이너리가 실행될 때 어떤 아키텍처 포맷인지 감지하고 이에 맞는 인터프리터를 제공한다. 

이러한 기술들을 종합하여 PC에서 다른 아키텍처와 OS임에도 불구하고 ARM 이미지가 실행되었던 것이다.

## 멀티 아키텍처 이미지를 빌드하는 방법

1. 여러 디바이스를 놓고 도커파일과 소스 파일을 분배하여 각자 빌드하는 방법. 배포를 위해 모든 빌드 머신이 필요하다.
2. Cross Compile. PC에 Cross compiler를 설치하고 빌드시에 이 컴파일러가 적용될 수 있도록 스크립트를 작성.
3. QEMU. 타켓 시스템을 에뮬레이팅하여 빌드하거나 사용자 공간만 에뮬레이션하여 빌드 할 수 있다.

## BuildX

- CLI 실험적 기능 중 하나
- 별도의 Dockerfile 작성 필요 없음
- Compose 빌드 지원
- Linux에서 사용시 커널 버전 4.8 이상, QEMU를 비롯한 별도 의존성 설치가 필요

## 후기

애플이 M1칩을 선보였다. 뛰어난 성능과 저전력의 특징을 가진 이 프로세서는 시장을 뒤흔들어놨다.

또한 AWS에서 얼마 전 Graviton2를 선보였다. 이 또한 ARM 아키텍처이다. 더 낮은 전력과 더 좋은 성능을 낮은 가격에 제공할 수 있게 되었다.

이에 개발자들의 숙제가 남아있다. 소프트웨어를 제공하는 개발자들은 ARM 아키텍처 호환성을 위해 숙제로 다가올 수도 있겠다.