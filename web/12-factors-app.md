# The Twelve Factors App

원본: [The Twelve-Factor App](https://12factor.net/ko/)

최근 소프트웨어를 서비스 형태로 제공하는게 일반화 되면서, 웹앱 혹은 `SaaS(Software As A Service)`라고 부르게 되었습니다. `Twelve-Factor app`은 아래 특징을 가진 SaaS 앱을 만들기 위한 방법론입니다.

- 설정 자동화를 위한 절차(declarative)를 체계화 하여 새로운 개발자가 프로젝트에 참여하는데 드는 시간과 비용을 최소화한다.
- OS에 따라 달라지는 부분을 명확히하고, 실행 환경 사이의 이식성을 극대화 한다.
- 최근 등장한 클라우드 플랫폼 배포에 적합하고, 서버와 시스템의 관리가 필요없게 된다.
- 개발 환경과 운영 환경의 차이를 최소화하고 민첩성을 극대화하기 위해 지속적인 배포가 가능하다.
- 도구, 아키텍처, 개발 방식을 크게 바꾸지 않고 확장(scale out) 할 수 있다.

Twelve-Factor 방법론은 어떤 프로그래밍 언어로 작성된 앱에도 적용할 수 있고 백엔드 서비스(데이터베이스, 큐, 메모리 캐시 등)와 다양한 조합으로 사용할 수 있다.

12개의 요인은 다음과 같습니다.

- [코드베이스](##코드베이스)
- [종속성](##종속성)
- [설정](##설정)
- [백엔드 서비스](##백엔드-서비스)
- [빌드, 릴리즈, 실행](##빌드,-릴리즈,-실행)
- [프로세스](##프로세스)
- [포트 바인딩](##포트-바인딩)
- [동시성](##동시성)
- [폐기 가능](##폐기-가능)
- [개발/프로덕션 환경 일치](##개발/프로덕션-환경-일치)
- [로그](##로그)
- [관리자 프로세스](##관리자-프로세스)

## 코드베이스
: 버전 관리가 용이한 하나의 코드베이스와 다양한 배포

버전 컨트롤 시스템을 사용하여 변화를 추적하며, 버전 추적 데이터베이스의 사본을 저장소*repository* 라고 합니다.

- 코드베이스가 여러개 있는 경우, 앱이 아니라 **분산 시스템**으로 봐야합니다. 분산 시스템의 개별 구성요소가 앱이 되며, 개별 앱이 `Twelve-Factor`를 따릅니다.
- 여러개 앱이 동일한 코드를 공유한다면 Twelve-Factor를 위반하는것입니다. 이를 해결하려면 공유하는 코드를 라이브러리화 시키고, 해당 라이브러리를 **종속성 매니저(예, nodejs의 package.json, pip의 requirement.txt)로 관리해야합니다.**

앱의 코드베이스는 한개여야 하지만, 앱 배포는 여러 개가 될 수 있습니다. 일반적인 배포는 **실행중인 앱의 인스턴스**를 가리킵니다. 운영 사이트, 스테이징 사이트, 로컬 개발 모두 하나의 배포로 볼 수 있습니다.

**배포마다 다른 버전이 활성화 될 수 있지만, 코드베이스 자체는 모든 배포에 대해 동일합니다.**

## 종속성
: 명시적으로 선언되고 분리된 종속성

대부분의 프로그래밍 언어는 라이브러리 배포를 위한 패키징 시스템을 제공합니다. Perl의 *CPAN* 이나 Ruby의 *Rubygems*, Python의 *pip*, Nodejs 의 *npm*이 대표적입니다. 라이브러리는 패키징 시스템을 통해 시스템 전체나 애플리케이션을 포함한 디렉토리(vendoring or bundling)에 설치될 수 있습니다.

**`Twelve-Factor App`은 전체 시스템에 특정 패키지가 암묵적으로 존재하는 것에 절대 의존하지 않습니다. 종속선 선언 *manifest*를 이용하여 모든 종속성을 완전하고 엄격하게 선언합니다.** 더 나아가, *종속성 분리* 툴을 사용하여 실행되는 동안 둘러싼 시스템으로 암묵적인 종속성 "유출"이 발생하지 않는 것을 보장합니다. 이런 완전적, 명시적 종속성의 명시는 개발과 서비스 모두에게 동일하게 적용됩니다.

파이썬을 예로 들면 `pip`은 종속성 선언을 위해, `virtualenv`는 종속성 분리를 위해 사용됩니다. 단적으로 파이썬의 예를 들었지만, **`Twelve-Factor App`을 만족하려면 종속성 선언과 분리, 두 가지를 모두 충족해야 합니다.**

**명시적인 종속성 선언의 장점 중 하나는 애플리케이션 개발에 새로 참가하게 된 개발자가 설치를 간단하게 할 수 있다는 점입니다.** 새로 참가한 개발자는 애플리케이션 코드베이스를 개발 머신에 체크아웃 하고, 언어의 런타임과 종속성 매니저만 설치한 후, 빌드 명령어만 입력하면 응용 프로그램의 코드를 실행하는 데 필요한 모든 것을 설치할 수 있습니다.

**`Twelve-Factor App`은 어떠한 시스템 도구에도 암시적으로 의존하지 않습니다.** 대표적인 도구인 `curl`은 시스템에 의존하며, 모든 시스템에 존재하는 것이 보장되지 않습니다. 미래 시스템에는 존재하지 않을 수도 있으며, 호환되는 버전이 있으라는 보장도 없습니다. **애플리케이션에게 시스템 도구가 필요하다면, 그 도구를 애플리케이션과 통합해야 합니다.**

## 설정
: 환경(environment)에 저장된 설정

애플리케이션 *설정*은 배포(스테이징, 프로덕션, 개발환경) 마다 달라질 수 있는 모든 것들입니다. 설정에는 다음이 포함됩니다.

- 데이터베이스, 캐시, 메세지 큐 등 *[백엔드 서비스](##백엔드-서비스)들의 리소스 핸들러*
- 페이스북, 트위터 등을 이용하는 *외부 서비스 인증 정보*
- 배포된 호스트의 정규화된 호스트 이름(canonical hostname)처럼 *각 배포마다 달라지는 값*

애플리케이션은 설정은 상수에 코드로 저장합니다. 이것은 `Twelve-Factor App`을 위반하며, 설정을 코드에서 엄격하게 분리하는것을 요구합니다. **설정은 배치(deploy)마다 크게 다르지만, 코드는 그렇지 않습니다.**

애플리케이션의 모든 설정이 정상적으로 코드베이스로부터 완전히 분리되어 있는지 확인할 수 있는 간단한 방법은 **어떤 인증정보도 유출시키지 않고 코드베이스가 지금 당장 오픈소스가 될 수 있는지 확인하는 것입니다.**

**설정에 대한 대표적인 접근방식 중 하나는 `.gitignore`같은 버전 관리 시스템에 파일이 등록되지 않도록하는 방법입니다.** 다만 이 방법은 설정 파일이 여러 위치에 여러 포맷으로 흩어지고 모든 설정을 한 곳에서 확인하고 관리하기 어려운 상황을 만들 수 있습니다. 추가적으로 이런 형식들은 언어와 프레임워크를 따라가는 경향이 있습니다.

**`Twelve-Factor App`은 설정을 환경변수(envvars 또는 env)에 저장합니다.** 환경 변수는 코드 변경 없이 쉽게 배포 때마다 쉽게 변경할 수 있습니다. 커스텀 설정 파일이나 Java System Property와 같은 다른 설정 매커니즘과 달리 언어나 OS에 의존하지 않는 표준입니다.

설정 관리의 다른 측면은 **그룹핑**입니다. **애플리케이션은 설정을 명명된 그룹(environments)로 구성하기도 합니다. 해당 그룹은 development, test, production 처럼 배포의 이름을 따라 명칭을 짓습니다.** 이 방법은 깔끔하게 확장되기 어렵습니다. 배포가 증가할 때마다 새로운 그룹의 이름이 필요하게 됩니다. 

**`Twelve-Factor App`에서 환경 변수는 매우 정교한 관리이며, 각각의 환경변수는 서로 직교합니다. 환경 변수는 그룹으로 묶이지 않고 각 배포마다 독립적으로 관리됩니다.** 이 모델은 애플리케이션 수명주기를 거치는 동안 더 많은 배포로 원활하게 확장해 나갈 수 있습니다.


## 백엔드 서비스

백엔드 서비스는 애플리케이션 동작 중 네트워크를 통해 이용하는 모든 서비스를 일컫습니다. 예를들어 *DB*, *Message queueing*, *SMTP*, *Cache service* 등이 있습니다.

전통적인 백엔드 서비스들은 통상적으로 배포된 애플리케이션과 같은 시스템 관리자에 의해 관리되고 있었습니다. 애플리케이션은 이런 로컬에서 관리하는 서비스 대신, 서드파티에 의해 제공되고 관리되는 서비스를 이용할 수 있습니다. 예를들어 AWS의 리눅스 컨테이너 제공 서비스인 *ECS*, AWS의 STMP 서비스 *SES*, AWS 오픈소스 인메모리 데이터베이스 서비스(Memcached 및 Redis) *Elasticache*등이 있습니다.

**즉 `Twelve-Factor App`의 코드는 로컬 서비스와 서드파티 서비스를 구별하지 않으며, 종속되지도 않아야 합니다.** 애플리케이션에게는 양 쪽 모두 연결된 리소스에 불과하며, [설정](##설정)에 있는 URL 혹은 다른 로케이터와 인증 정보를 사용하여 접근됩니다. 또한 [배포](##배포)는 애플리케이션 코드를 수정하지 않고 로컬에서 관리되는 백엔드 서비스(예, *MySQL*)를 서드파티에서 관리되는 DB(예, *Amazon RDS*)로 전환할 수 있어야 합니다. 다른 경우여도 마찬가지이며, 모든 경우에서 모두 설정에 있는 리소스 핸들만 변경하면 됩니다.

각각의 다른 백엔드 서비스는 *리소스*입니다. 만약 데이터베이스를 샤딩한다고 생각한다면, 각 샤드를 서로 다른 *리소스*라 할 수 있습니다. `Twelve-Factor App`은 이러한 백엔드 서비스를 *loosely coupled resource*로 다룹니다.

백엔드의 리소스는 자유롭게 배포에 연결되거나 분리될 수 있습니다. 예를 들어, 애플리케이션의 데이터베이스가 하드웨어 이슈로 작동에 이상이 생겼을 경우, 애플리케이션 관리자는 최신 백업을 기반으로 새로운 데이터베이스를 구축합니다. 그리고 코드 수정 없이 이상이 생긴 데이터베이스를 분리하고 새로운 데이터베이스를 연결할 수 있습니다.

## 빌드, 릴리즈, 실행
: 철저하게 분리된 빌드와 실행 단계

[코드베이스](##코드베이스)는 빌드, 릴리즈, 실행의 3단계를 거쳐 배포로 변환됩니다.

- **빌드 단계**에서는 코드 저장소를 *빌드*라는 실행 가능한 번들로 변환하는 단계입니다. 빌드 단계에서는 커밋된 코드 중 배포 프로세스에서 지정된 버전을 사용하며, [종속성](##종속성)을 가져와 바이너리와 에셋들을 컴파일합니다.
- **릴리즈 단계**에서는 빌드 단계에서 만들어진 빌드와 배포의 현재 [설정](#설정)을 결합합니다. 완성된 *릴리즈*는 빌드와 설정을 모두 포함하여 실행 환경에서 바로 실행될 수 있도록 준비됩니다.
- **실행(런타임) 단계**에서는 선택된 릴리즈에 대한 애플리케이션 [프로세스](##프로세스)의 집합을 시작하여, 애플리케이션을 실행 환경에서 돌아가도록 합니다.

**`Twelve-Factor App`은 빌드, 릴리즈, 실행 단계를 엄격히 서로 분리합니다.** 단적인 예로, 실행 단계에서 코드를 변경할 수 없습니다.

배포 도구는 일반적으로 릴리즈 도구를 제공합니다. 특히 주목 할만한 점은 이전 릴리즈로 되돌릴 수 있는 *롤백*입니다.

모든 릴리즈는 항상 유니크한 릴리즈 ID를 지녀야 합니다. 예를 들어 타임 스탬프나 증가하는 번호등이 있습니다. 릴리즈는 추가만 가능하며 한 번 만들어진 릴리즈는 변경될 수 없습니다. 모든 변경은 새로운 릴리즈에서 구현됩니다.

빌드는 새로운 코드가 배포 될 때마다 개발자에 의해 시작됩니다. 반면, 실행 단계는 서버가 재부팅되거나 충돌이 발생한 프로세스가 프로세스 매니저에 의해 재시작 되었을 때 자동으로 실행될 수 있습니다. 따라서 대응할 수 있는 개발자가 없는 한 밤 중에 문제가 발생하는 것을 방지하기 위해, 실행 단계에는 최대한 변화가 적어야 합니다. 

## 프로세스
: 애플리케이션을 하나 혹은 여러개의 무상태(stateless) 프로세스로 실행

실행 환경에서 앱은 하나 이상의 *프로세스*로 실행됩니다.

가장 간단한 케이스는 코드가 standalone 스크립트인 경우입니다. 복잡한 케이스로는 많은 [프로세스 타입별로 여러개의 프로세스가 사용되는 복잡한 애플리케이션(동시성)](##동시성)이 있습니다.

`Twelve-Factor App` 프로세스는 무상태이며, 프로세스간 공유하는 것이 아무것도 없어야 합니다. 유지될 필요가 있는 모든 데이터는 데이터베이스와 같은 안정된 [백엔드 서비스](##백엔드-서비스)에 저장되어야 합니다.

짧은 단일 트랜잭션 내에서 캐시로 프로세스의 메모리 공간이나 파일 시스템을 사용해도 됩니다. 예를 들어, 큰 파일을 받아 해당 파일을 처리하고, 그 결과를 데이터베이스에 저장하는 경우가 있습니다. **`Twelve-Factor App`에서 절대로 메모리나 디스크에 캐시된 내용이 미래의 요청이나 작업에서도 유효할 것이라고 가정해서는 안됩니다.** 각 프로세스 타입의 프로세스가 여러 개 돌아가고 있는 경우, 미래의 요청은 다른 프로세스에 의해 처리될 가능성이 높습니다. 하나의 프로세스만 돌고 있는 경우에도 여러 요인에 의해 발생하는 재실행은 보통 모든 로컬의 상태(메모리와 파일 시스템 등)를 없앱니다.

에셋 패키징 도구(예: *jammit*, *django-assetpackager*)는 컴파일된 에셋을 저장할 캐시로 파일 시스템을 사용합니다. **`Twelve-Factor App`은 이러한 컴파일을 런타임에 진행하기 보다는, 빌드 단계에서 수행하는 것을 권장합니다.**

웹 시스템 중에는 *Sticky session*(계속되는 통신이 아닌 일시적으로 자주 사용되는 세션)에 의존하는 것들도 있습니다. 이는 유저의 세션 데이터를 앱의 프로세스 메모리에 캐싱하고, 같은 유저의 이후 요청에도 같은 프로세스를 전달할 것은 가정하는(일종의 캐시) 것입니다. *Sticky session*은 `Twelve-Factor App`에 위반되며, 의존해서는 안됩니다. **세션 상태 데이터는 `Memcached`나 `Redis`처럼 유효기간을 제공하는 데이터 저장소에 저장하는 것이 적합합니다.**

## 포트 바인딩
: 포트 바인딩을 사용하여 서비스를 공개

웹앱은 웹서버 컨테이너 내부에서 실행되기도 합니다. 예를 들어 PHP앱은 Apache HTTPD 모듈로 실행될 수도 있고, Java 앱은 Tomcat 내부에서 실행될 수도 있습니다.

**`Twelve-Factor App`은 완전 독립적이며 웹서버가 웹 서비스를 만들기 위해 처리하는 실행 환경에 대한 런타임 인젝션에 의존하지 않습니다.** `Twelve-Factor App`은 포트를 바인딩하여 HTTP 서비스로 공개되며 그 포트로 들어오는 요청을 기다립니다. 즉, 배포되는 앱에서는 라우팅 레이어(Nginx, Apache 등 웹서버)가 외부에 공개된 호스트(HTTP 또는 HTTPS 도메인)명으로 들어온 요청을 포트에 바인딩(배포 머신에서 사용하는 커스텀 포트)된 웹 프로세스에 전달합니다.

이는 일반적으로 [종속성](##종속성) 선언에 웹서버 라이브러리를 추가함으로써 구현됩니다. 예를 들어, Python의 *Tornado*, Ruby의 *Thin*, Java 및 JVM 기반 언어들을 위한 *Jetty*가 있습니다. 이것들은 전적으로 *유저 스페이스* 즉, 애플리케이션의 코드 내에서 처리됩니다. **실행 환경과 규약은 요청을 처리하기 위한 포트를 바인딩하는 것입니다.**

거의 모든 종류의 서버 소프트웨어는 포트를 바인딩하고 요청이 들어오길 기다리는 프로세스를 통해 실행될 수 있습니다. **예로 도커*docker*위에서 구동되는 애플리케이션들을 구동되는 머신의 포트를 지정하면서 컨테이너 내부의 애플리케이션이 사용하는 포트를 연결하여 사용할 수 있습니다.** 이 경우, 같은 애플리케이션을 사용하는 다수의 프로세스가 존재해야 하는 경우 유용하게 쓰일 수 있습니다.

**결국, 포트 바인딩을 사용한다는 것은 하나의 앱이 다른 앱을 위한 백엔드 서비스가 될 수 있다는 것을 의미한다는 점에 주목합시다.** 백엔드 앱의 URL을 사용할 앱의 [설정](##설정)의 리소스 핸들로 추가하는 방식으로 앱이 다른 앱을 백엔드 서비스로 사용할 수 있습니다.

## 동시성
: 프로세스 모델을 통한 확장

모든 컴퓨터 프로그램은 실행되면 하나 이상의 프로세스로 표현됩니다. 웹 애플리케이션은 다양한 프로세스 실행 형태를 취해왔습니다. 예를 들어 PHP 프로세스는 Apache의 자식 프로세스로 실행되며, request의 양에 따라 필요한 만큼 시작됩니다. 자바 프로세스들은 반대 방향에서의 접근법을 취합니다. JVM은 시작될 때 큰 시스템 리소스(CPU와 메모리) 블록을 예약하는 하나의 거대한 부모 프로세스를 제공하고, 내부 스레드를 통해 동시성을 관리합니다. 두 경우 모두 실행되는 프로세스는 애플리케이션 개발자에게 최소한으로 노출됩니다.

`Twelve-Factor App`에서 프로세스들은 일급 시민입니다. **`Twelve-Factor App`에서의 프로세스는 서비스 데몬들을 실행하기 위한 유닉스 프로세스 모델**에서 큰 힌트를 얻었습니다. 이 모델을 사용하면 개발자는 애플리케이션의 작업을 적절한 프로세스 타입에 할당함으로서 다양한 작업 부하를 처리할 수 있도록 설계할 수 있습니다. 예를 들어, HTTP 요청은 웹 프로세스가 처리하며, 시간이 오래 걸리는 백그라운드 작업은 worker 프로세스가 처리하도록 할 수 있습니다.

이는 런타임 VM 내부의 스레드나 *EventMachine*, *Twisted*, *Node.js* 에서 구성된 것처럼 async/evented 모델처럼 개별 프로세스가 내부적으로 동시에 처리하는 것을 금지하는 것은 아닙니다. 하지만 개별 VM이 수직적 확장으로 너무 커질 수 있습니다. 따라서 애플리케이션은 여러개의 물리적인 머신에서 돌아가는 여러 개의 프로세스로 넓게 퍼질 수 있어야만 합니다.(수평적 확장이 가능해야 합니다.)

**프로세스 모델이 진정으로 빛나는 것은 수평적으로 확장하는 경우입니다.** 아무것도 공유하지 않고, 수평으로 분할할 수 있는 `Twelve-Factor App` 프로세스의 성질은 동시성을 높이는 간단하고 안정적인 작업이라는 것을 의미합니다. 프로세스의 타입과 각 타입별 프로세스의 갯수의 배치를 `process formation` 이라 합니다.

`Twelve-Factor App` 프로세스는 절대 데몬화해서는 안되며, PID파일을 작성해서는 안됩니다. 대신, OS의 프로세스 관리자나 클라우드 플랫폼의 분산 프로세스 매니저, 혹은 foreman 같은 툴에 의존하여 output stream을 관리하고, 충돌이 발생한 프로세스에 대응하고 재시작과 종료를 처리해야 합니다.

## 폐기 가능
: 빠른 시작과 graceful shutdown을 통한 안정성 극대화

**`Twelve-Factor App`의 [프로세스](##프로세스)는 간단히 폐기가 가능합니다. 즉, 프로세스는 바로 시작하거나 종료될 수 있습니다.** 이러한 속성은 신축성 있는 확장과 코드나 설정의 변화를 빠르게 배포하는 것을 쉽게 하며, 프로덕션 배포를 안정성있게 해줍니다.

프로세스는 시작 시간을 최소화하도록 노력해야 합니다. 이상적으로, 프로세스는 실행 커맨드가 실행된 뒤 몇 초만에 요청이나 작업을 받을 수있도록 준비되어야 합니다. 짧은 실행은 릴리즈 작업과 확장이 더 민첩하게 이루어질 수 있게 합니다. 또한 프로세스 매니저가 필요에 따라 쉽게 프로세스를 새로운 머신이 프로세스를 옮길 수 있기 때문에 안정성도 높아집니다.

프로세스는 프로세스 매니저로부터 `SIGTERM(SIGNAL-TERMINATION)` 신호를 받았을 때 *graceful shutdown*을 합니다. 웹프로세스의 graceful shutdown 과정에는 서비스 포트의 수신을 중지하고(이로써 새로운 요청을 거절합니다.), 현재 처리중인 요청이 끝나길 기다린 뒤에 프로세스가 종료되게 됩니다. 이 모델은 암묵적으로 HTTP요청이 짧다는 가정을 전제로 합니다. Long polling일 경우 클라이언트가 연결이 끊긴 시점에서 바로 다시 연결을 시도해야 합니다.

worker 프로세스의 경우, graceful shutdown은 현재 처리중인 작업을 작업 큐로 되돌리는 방법으로 구현됩니다. 예를 들어, *RabbitMQ*에서는 worker는 `NACK`를 메시지큐로 보내고, *Beanstalkd*에서는 worker와의 연결이 끊길 때 작업을 큐로 되돌리는 방법을 택합니다. *Delayed Job*과 같은 Lock-based 시스템들은 작업 레코드에 걸어놨던 lock을 확실하게 풀어놓을 필요가 있습니다. 이 모델은 암묵적으로 모든 작업을 재입력 가능(re-entrant)하다고 가정합니다. 이는 보통, 결과를 트랜잭션으로 감싸거나 요청을 *멱등(idempotent)*하게 함으로써 구현될 수 있습니다.

프로세스는 하드웨어 에러에 의한 **갑작스러운 죽음에도 견고해야 합니다.** 이러한 사테는 `SIGTERM`에 의한 graceful shutdown에 비하면 드문 일이지만, 발생의 여지는 있습니다. **이런 일에 대한 대책으로 *Beanstalkd*와 같은 견고한 큐잉 백엔드를 사용하는 것을 권장합니다.** 이러한 백엔드는 클라이언트가 접속이 끊기거나, 타임 아웃이 발생했을 때, 작업을 큐로 돌립니다.

## 개발/프로덕션 환경 일치
: development, staging, production 환경을 최대한 비슷하게 유지

역사적으로, 개발 환경(애플리케이션의 개발자가 직접 수정하는 로컬의 배포)과 프로덕션 환경(최종 사용자가 접근하게 되는 실행 중인 배포) 사이에는 큰 차이가 있었습니다. 이러한 차이는 3가지 영역에 걸쳐 나타납니다.

- **시간의 차이**: 개발자가 작업한 코드는 프로덕션 배포에 반영되기 전까지 며칠, 몇 주, 때로는 몇 개월이 걸릴 수 있습니다.
- **담당자의 차이**: 개발자가 작성한 코드를 개발자가 아닌 시스템 엔지니어가 배포합니다.
- **툴의 차이**: 개발 환경과 프로덕션의 환경이 다를 수 있습니다.

`Twelve-Factor App`은 개발 환경과 프로덕션 환경의 차이를 작게 유지하여 [지속적인 배포]()가 가능하도록 디자인됩니다. 위의 3가지 차이에 대한 대응책은 다음과 같습니다.

- **시간의 차이를 최소화**: 개발자가 작성한 코드는 몇 시간, 몇 분 뒤에 배포될 수도 있습니다.
- **담당자의 차이를 최소화**: 코드를 작성한 개발자들이 배포와 프로덕션에서의 모니터링에 깊게 관여합니다.
- **툴의 차이를 최소화**: 개발과 프로덕션 환경을 최대한 비슷하게 유지합니다.

위의 내용을 요약한 표입니다.

---
|  | 전통적인 애플리케이션 | Twelve-Factor App |
| --- | --- | --- |
| 배포 간의 간격 | 몇 주 | 몇 시간 |
| 코드 작성자와 코드 배포자 | 다른 사람 | 같은 사람 또는 깊게 관여 |
| 개발 환경과 프로덕션 환경 | 불 일치 | 최대한 유사 |

데이터베이스, 큐잉 시스템, 캐시와 같은 [백엔드 서비스](##백엔드_서비스)는 개발/프로덕션 일치가 중요한 영역 중 하나입니다. 많은 언어들은 다른 종류의 서비스에 대한 *어댑터(Adapter)*를 포함하고 간단하게 백엔드 서비스에 접근할 수 있는 라이브러리들을 제공합니다. 아래의 표에 몇가지 예가 있습니다.

---
| 종류 | 언어 | 라이브러리 | 어댑터 |
| --- | --- | --- | --- |
| 데이터베이스 | Ruby/Rails | ActiveRecord | MySQL, PostgreSQL, SQLite |
| 큐 | Python/Django | Celery | RabbitMQ, Beanstalkd, Redis |
| 캐시 | Ruby/Rails | ActiveSupport::Cache | 메모리, 파일시스템, Memcached |

프로덕션 환경에서는 더 본격적이고 강력한 백엔드 서비스가 사용됨에도 불구하고, 개발자는 자신의 로컬 개발 환경에서는 가벼운 백엔드 서비스를 이용하는 것에 큰 매력을 느낄 수 있습니다. 예를 들어 로컬에서는 SQLite를 사용하고, 프로덕션에서는 PostgreSQL을 사용한다던가, 개발 중에는 로컬 프로세스의 메모리를 캐싱용으로 사용하고 프로덕션에서는 Memcached나 Redis를 사용하는 경우가 있습니다.

**`Twelve-Factor App` 개발자는 개발 환경과 프로덕션 환경에서 다른 백엔드 서비스를 쓰고 싶은 충동에 저항해야 합니다.** 이론적으로 어댑터가 백엔드 서비스 간의 차이를 추상화 해준다고해도, 백엔드 서비스 간의 약간의 불일치가 개발 환경과 스테이징 환경에서는 동작하고 테스트에 통과된 코드가 프로덕션 환경에서는 오류를 일으킬 수 있기 때문입니다. 이런 종류의 오류는 지속적인 배포를 방해합니다. 애플리케이션 생명 주기 전체를 보았을 때, 이러한 방해와 지속적인 배포의 둔화가 발생하는 손해는 매우 큽니다.

여러 백엔드 서비스에 접근할 수 있는 *어댑터*는 여전히 유용합니다. 새로운 백엔드 서비스를 사용하도록 포팅하는 작업의 고통을 낮춰주기 때문입니다. 하지만, 모든 애플리케이션의 배포들(개발자 환경, 스테이징, 프로덕션)은 같은 종류, 같은 버전의 백엔드 서비스를 이용해야합니다.

## 로그
: 로그를 이벤트 스트림으로 취급

*로그*는 실행중인 앱의 동작을 확인할 수 있는 수단입니다. 서버 기반 환경에서 로그는 보통 디스크에 파일로 저장됩니다. 

로그는 모든 실행중인 프로세스와 백그라운드 서비스의 아웃풋 스트림으로부터 수집된 이벤트가 시간 순서로 정렬된 *스트림*입니다. 가공되지 않는 로그는 보통 하나의 이벤트가 하나의 라인으로 기록된 텍스트 포맷입니다.(exception에 의한 stacktrace는 여러 라인에 걸쳐 있을 수도 있습니다.) 로그는 고정된 시작과 끝이 있는 것이 아니라, 앱이 실행되는 동안 계속 흐르는 흐름입니다.

**`Twelve-Factor App`은 아웃풋 스트림의 전달이나 저장에 절대 관여하지 않습니다. 앱은 로그 파일을 작성하거나, 관리하려고 해서는 안됩니다.** 대신, 각 프로세스는 이벤트 스트림을 버퍼링 없이 `stdout`에 출력합니다. 로컬 개발환경에서 작업 중인 개발자는 앱의 동작을 관찰하기 원하면 각자의 터미널에 출력되는 이 스트림을 볼 수 있습니다.

예를 들어 도커 환경에서는 서버 쉘에서 아래의 스크립트를 실행합니다.

```bash
# 마지막 100 줄만 보기
docker logs \<container-name\> --tail 100

# 현재 진행되고 있는 로그를 실시간으로 확인하는 스크립트
docker logs \<contaier-name\> -f
```

스테이징이나 프로덕션 배포에서는 각 프로세스의 스트림은 실행 환경에 의해 수집된 후, 앱의 다른 모든 스트림과 병합되어 열람하거나 보관하기 위한 하나 이상의 최종 목적지로 전달됩니다. 이러한 목적지들은 앱이 열람하거나 설정할 수 없지만, 대신 실행 환경에 의해 완벽하게 관리됩니다. 이를 위해 오픈 소스 로그 라우터를 사용할 수 있습니다.(예: *Logplex, Fluentd*)

앱의 이벤트 스트림은 파일로 보내지거나 터미널에서 실시간으로 보여질 수 있습니다. **가장 중요한 점은 스트림은 *Splunk*같은 로그 분석 시스템과 *Hadoop/Hive* 같은 범용 데이터 보관소, 또는 *ELK 스택*같은 시각화 엔드포인트에 보내질 수 있다는 점입니다.** 이러한 시스템은 장기간에 걸쳐 앱의 동작을 조사할 수 있는 강력함과 유연성 및 인사이트를 가지게 됩니다.

- 과거의 특정 이벤트를 찾기
- 트렌드에 대한 거대한 규모의 그래프(예: 초당 응답 수*RPS*)
- 유저가 정의한 휴리스틱에 따른 알림(예: 분당 오류 수*EPM*가 임계 값을 넘는 경우 알림을 발생)

## 관리자 프로세스
: admin/maintenance 작업을 일회성 프로세스로 실행

*프로세스 포메이션*은 애플리케이션의 일반적인 기능들(예: Web request 처리)을 처리하기 위한 프로세스들의 집합입니다. 이와는 별도로, 개발자들은 종종 일회성 관리나 유지보수 작업이 필요합니다. 그 예는 아래와 같습니다.

- 데이터베이스 마이그레이션
- 임의의 코드를 실행하거나 라이브 데이터베이스에서 앱 모델을 조사하기 위해 콘솔(REPL Shell)을 실행
- 애플리케이션 저장소에 커밋된 일회성 스크립트의 실행

일회성 admin 프로세스는 애플리케이션의 일반적인 오래 실행되는 프로세스들과 동일한 환경에서 실행되어야 합니다. **일회성 admin 프로세스들은 릴리즈를 기반으로 실행되며, 해당 릴리즈를 기반으로 돌아가는 모든 프로세스처럼 같은 [코드베이스](#코드베이스)와 [설정](#설정)을 사용해야 합니다. 또한 admin 코드는 동기화 문제를 피하기 위해 애플리케이션 코드와 함께 배포되어야 합니다.**

모든 프로세스 타입들에는 동일한 종속성 분리 기술이 사용되어야 합니다. 

Ruby의 경우 다음의 명령어로 종속성을 분리할 수 있습니다.

```bash
# Ruby 웹 프로세스
$ bundle exec this start

# 데이터베이스 마이그레이션
$ bundle exec rake db:migrate
```

Node.js는 아래처럼 사용합니다.

```bash
# Node.js 웹 프로세스
$ npm run prod

# 도커 환경에서 테스트
$ npm run test:docker
```

`Twelve-Factor App`는 별도의 설치나 구성 없이 REPL Shell을 제공하는 언어를 선호합니다. 이러한 점은 일회성 스크립트를 실행하기 쉽게 만들어 주기 때문입니다. 로컬 배포에서 개발자는 앱을 체크아웃한 디렉토리에서 일회성 admin 프로세스를 shell 명령어로 바로 실행시킵니다. 프로덕션 배포에서, 개발자는 ssh나 배포의 실행 환경에서 제공하는 다른 원격 명령어 실행 매커니즘을 사용하여 admin 프로세스를 실행할 수 있습니다.